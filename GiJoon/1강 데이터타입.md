# 1강

### 데이터 타입의 종류

- 유일하게 몰랐던 데이터 타입 `Symbol`

  역할 : `Symbol` 데이터 타입은 `JS`에서 고유하고 변경할 수 없는 값을 생성하는 데 사용됩니다. 주로 객체의 프로퍼티 키로 사용되며, 다른 어떤 값과도 중복되지 않는 고유한 식별자를 생성하는 역할을 가졌습니다.

  안쓰이는 이유 : 대부분 고유한 프로퍼티 키를 만드는 것보다 문자열을 사용한 프로퍼티 키가 더 유연하게 사용가능합니다.  또한 타입 기반 상수 집합 같은 경우 `typescript`에서는 `enum`을 지원합니다. `Enum`과 Object 데이터 타입으로 충분이 대체 가능하여 Symbol 데이터 타입의 가치가 상대적으로 낮은 것 같습니다.

  ```jsx
  const STATUS = {
    START: Symbol('START'),
    STOP: Symbol('STOP')
  }
  if(status == STATUS.START) console.log("state is START")

  else if(status == STATUS.STOP) console.log("state is STOP")
  ```

### 데이터 타입에 관한 배경지식

- 메모리와 데이터

  물리적으로 메모리가 부족했던 시절에 메모리를 아끼기 위해서 같은 숫자라도 `Int,Short,Long` 타입으로 나눴던 시절에 대한 설명입니다. C언어를 사용할 때 왜 그렇게 메모리 할당크기에 주의를 기울였는지 알 수 있었습니다.
- 식별자와 변수

  평소에 식별자와 변수의 의미 차이를 구분하지 않고 통틀어서 변수라고 불렀는데, 이 개념을 읽고 나니 그 차이가 더 명확해진 것 같습니다.

  let a = 1

  a는 식별자(변수명) 1은 변수

변수 선언과 데이터 할당

- 변수선언
- 데이터할당

  개인적으로 데이터 할당 할 때 컴퓨터 내에서

  let a

  a = “abc”
  주소: 식별자 “a”, 값:”abc”

  심플하게 주소에 전부 할당되는 줄 알았으나
  데이터 영역과 변수 영역 분리해서 관리한다는 것을 깨달았습니다.

### 불변값

불변값은 값이 한 번 생성되면 변경되지 않는 데이터입니다. 처음에는 `const`처럼 값을 변경할 수 없는 것을 불변값이라 생각했으나, 실제로는 기본형 데이터의 특성으로, 값이 변경될 때마다 새로운 값이 생성되는 것을 의미합니다.

```jsx
코드 복사
let a = 0
a = a + 1  // 기존 값에 +1을 하는 것이 아니라, 새로운 값 1이 할당됩니다.
```

새로운 값이 할당될 때마다 기존 값을 변경하는 것이 아니라, 새로운 메모리 공간에 값을 저장하는 방식으로 처리됩니다.

### 가변값 (Mutable Values)

참조형 데이터는 가변값처럼 보이지만 사실 다릅니다. 참조형 데이터의 경우 객체나 배열과 같은 구조체는 불변값과 다르게 값 자체를 변경할 수 있습니다.

```jsx
const obj = { a: 1, b: 2 }
```

여기서 `obj`는 `a`와 `b`라는 불변값들이 저장된 공간을 가리키는 주소를 참조하고 있습니다. 즉, `obj` 자체는 불변값처럼 보이지만, 객체 내부의 프로퍼티들은 변경될 수 있습니다.

```jsx
obj.a = 3  // 프로퍼티 a의 값만 변경됨
```

- 기본형 데이터는 **불변값**이며, 값이 변경될 때마다 새로운 값을 할당합니다.
- 참조형 데이터는 **가변값**처럼 보이지만, 사실 프로퍼티만 변경될 수 있습니다. 객체 자체가 아닌 객체 내부의 값이 변경되는 것이기 때문에 객체는 여전히 참조형으로 관리됩니다.

## 얕은 복사와 깊은 복사

### 얕은 복사

**얕은 복사**는 객체의 1단계까지만 복사하는 방식입니다. 객체의 프로퍼티 중 참조형 데이터가 있을 경우, 그 참조형 데이터의 주소만 복사됩니다. 즉, 복사된 객체의 내부 참조형 데이터는 원본 객체와 동일한 메모리 주소를 참조합니다.

```jsx

//복사
let original = { a: 1, b:{c:2}}
//copyObj라는 메서드는 없음 책에 그냥 있는 예시임
let lightCopy = copyObj(original) 

lightCopy.b.c = 3
console.log(original.b.c === lightCopy.b.c) //true
// 같은 주소를 공유하기 때문에 값이 바뀌면 같이바뀜
```

### 깊은 복사

**깊은 복사**는 객체의 모든 중첩된 구조까지 새로운 메모리 공간에 복사하는 방식입니다. 따라서 원본 객체와 복사된 객체는 완전히 독립적인 메모리 공간을 가지며, 한쪽을 수정해도 다른 쪽에 영향을 주지 않습니다.(주소 공유 X)

```jsx

//코드 복사
let origin = {a: 1, b:{c: 2}}
//copyObj라는 메서드는 없음 책에 그냥 있는 예시임
let deepCopy =  copyObj(original)

deepCopy.b.c = 3
console.log(original.b.c === lightCopy.b.c) //false
// 독립적 주소기 때문에 false
```

- 얕은 복사는 성능상 유리할 수 있지만, 참조형 데이터가 포함된 객체의 경우 원본과 복사본이 서로 영향을 주게 됩니다.
- 깊은 복사는 참조형 데이터의 독립성을 보장하지만, 메모리 사용이 증가하고 성능에 영향을 줄 수 있습니다.

## undefined와 null

### undefined

자바스크립트 엔진은 **사용자가 값을 지정할 것이라고 예상하지만, 지정되지 않은 상황**에서 `undefined`를 반환합니다.

### undefined가 반환되는 상황

- **값을 할당하지 않은 변수**에 접근할 때 (즉, 데이터 영역의 메모리 주소가 없는 식별자).
- **객체 내부의 존재하지 않는 프로퍼티**에 접근할 때.
- **return 문이 없는 함수**를 호출한 후 결과를 사용할 때.

### 비어 있는 요소

배열 메서드에서 '비어 있는 요소'는 **순회 대상에서 제외**됩니다. 즉, 존재하지 않는 프로퍼티에 대해서는 순회할 수 없습니다.

### 배열에 대한 착각

배열은 무조건 `length` 프로퍼티만큼의 빈 공간을 확보하는 것이 아닙니다. 실제로는 **특정 인덱스에 값을 지정**할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하며, 데이터의 주소를 저장합니다. 값이 지정되지 않은 인덱스는 **존재하지 않는 프로퍼티**로 간주됩니다.

### 두 가지 유형의 undefined

- **값으로써 의도적으로 할당된 `undefined`**: 명시적으로 할당된 데이터
- **자바스크립트 엔진이 반환한 `undefined`**: 값이 할당되지 않은 상태를 나타내는 시스템의 반환값

### null 사용 시 주의할 점

`typeof null`의 결과는 `object`니다. 이는 자바스크립트 엔진의 유명한 **버그**

### **읽고 떠오름**

예전에 Redux를 이용해 `Obj` 데이터 타입으로 전역 변수를 만들고, 그 값을 그대로 반환하여 `enum`을 이용한 여러 모달 상태 관리 기능을 묶어서 구현했었습니다.  하지만 비교 결과가 무조건 `false`가 나와서 모달이 표시되지 않는 문제가 있었는데, 당시에는 `Redux`자체 문제인 줄 알았습니다. (원래 Redux랑 React가 호환성이 별로임)

지금 보니 이 문제는 **얕은 복사** 때문에 발생한 것이었습니다. `Redux`에서 반환된 객체와 `enum`을 비교할 때, 두 객체의 참조가 다르기 때문에 내부 값이 같더라도 `false`가 반환됬던 겁니다.  반환한 값이 **새로운 객체**니까 주소 참조가 달라 비교가 실패한 것을 지금 깨달았습니다. 아… 감사합니다 코어 자바스크립트
